{"version":3,"file":"sessionid.js","sourceRoot":"","sources":["../../src/sessionid.ts"],"names":[],"mappings":"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","sourcesContent":["import { PostHogPersistence, SESSION_ID } from './posthog-persistence'\nimport { sessionStore } from './storage'\nimport { _UUID } from './utils'\nimport { PostHogConfig } from './types'\n\nconst SESSION_CHANGE_THRESHOLD = 30 * 60 * 1000 // 30 mins\nconst SESSION_LENGTH_LIMIT = 24 * 3600 * 1000 // 24 hours\n\nexport class SessionIdManager {\n    config: Partial<PostHogConfig>\n    persistence: PostHogPersistence\n    _windowId: string | null | undefined\n    _sessionId: string | null | undefined\n    window_id_storage_key: string\n    primary_window_exists_storage_key: string\n    _sessionStartTimestamp: number | null\n    _sessionActivityTimestamp: number | null\n\n    constructor(config: Partial<PostHogConfig>, persistence: PostHogPersistence) {\n        this.config = config\n        this.persistence = persistence\n        this._windowId = undefined\n        this._sessionId = undefined\n        this._sessionStartTimestamp = null\n        this._sessionActivityTimestamp = null\n\n        const persistenceName = config['persistence_name'] || config['token']\n\n        this.window_id_storage_key = 'ph_' + persistenceName + '_window_id'\n        this.primary_window_exists_storage_key = 'ph_' + persistenceName + '_primary_window_exists'\n\n        // primary_window_exists is set when the DOM has been loaded and is cleared on unload\n        // if it exists here it means there was no unload which suggests this window is opened as a tab duplication, window.open, etc.\n        if (this._canUseSessionStorage()) {\n            const lastWindowId = sessionStore.parse(this.window_id_storage_key)\n\n            const primaryWindowExists = sessionStore.parse(this.primary_window_exists_storage_key)\n            if (lastWindowId && !primaryWindowExists) {\n                // Persist window from previous storage state\n                this._windowId = lastWindowId\n            } else {\n                // Wipe any reference to previous window id\n                sessionStore.remove(this.window_id_storage_key)\n            }\n            // Flag this session as having a primary window\n            sessionStore.set(this.primary_window_exists_storage_key, true)\n        }\n\n        this._listenToReloadWindow()\n    }\n\n    _canUseSessionStorage(): boolean {\n        // We only want to use sessionStorage if persistence is enabled and not memory storage\n        return this.config.persistence !== 'memory' && !this.persistence.disabled && sessionStore.is_supported()\n    }\n\n    // Note: this tries to store the windowId in sessionStorage. SessionStorage is unique to the current window/tab,\n    // and persists page loads/reloads. So it's uniquely suited for storing the windowId. This function also respects\n    // when persistence is disabled (by user config) and when sessionStorage is not supported (it *should* be supported on all browsers),\n    // and in that case, it falls back to memory (which sadly, won't persist page loads)\n    _setWindowId(windowId: string): void {\n        if (windowId !== this._windowId) {\n            this._windowId = windowId\n            if (this._canUseSessionStorage()) {\n                sessionStore.set(this.window_id_storage_key, windowId)\n            }\n        }\n    }\n\n    _getWindowId(): string | null {\n        if (this._windowId) {\n            return this._windowId\n        }\n        if (this._canUseSessionStorage()) {\n            return sessionStore.parse(this.window_id_storage_key)\n        }\n        // New window id will be generated\n        return null\n    }\n\n    // Note: 'this.persistence.register' can be disabled in the config.\n    // In that case, this works by storing sessionId and the timestamp in memory.\n    _setSessionId(\n        sessionId: string | null,\n        sessionActivityTimestamp: number | null,\n        sessionStartTimestamp: number | null\n    ): void {\n        if (\n            sessionId !== this._sessionId ||\n            sessionActivityTimestamp !== this._sessionActivityTimestamp ||\n            sessionStartTimestamp !== this._sessionStartTimestamp\n        ) {\n            this._sessionStartTimestamp = sessionStartTimestamp\n            this._sessionActivityTimestamp = sessionActivityTimestamp\n            this._sessionId = sessionId\n            this.persistence.register({\n                [SESSION_ID]: [sessionActivityTimestamp, sessionId, sessionStartTimestamp],\n            })\n        }\n    }\n\n    _getSessionId(): [number, string, number] {\n        if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp) {\n            return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp]\n        }\n        const sessionId = this.persistence.props[SESSION_ID]\n\n        if (Array.isArray(sessionId) && sessionId.length === 2) {\n            // Storage does not yet have a session start time. Add the last activity timestamp as the start time\n            sessionId.push(sessionId[0])\n        }\n\n        return sessionId || [0, null, 0]\n    }\n\n    // Resets the session id by setting it to null. On the subsequent call to checkAndGetSessionAndWindowId,\n    // new ids will be generated.\n    resetSessionId(): void {\n        this._setSessionId(null, null, null)\n    }\n\n    /*\n     * Listens to window unloads and removes the primaryWindowExists key from sessionStorage.\n     * Reloaded or fresh tabs created after a DOM unloads (reloading the same tab) WILL NOT have this primaryWindowExists flag in session storage.\n     * Cloned sessions (new tab, tab duplication, window.open(), ...) WILL have this primaryWindowExists flag in their copied session storage.\n     * We conditionally check the primaryWindowExists value in the constructor to decide if the window id in the last session storage should be carried over.\n     */\n    _listenToReloadWindow(): void {\n        window.addEventListener('beforeunload', () => {\n            if (this._canUseSessionStorage()) {\n                sessionStore.remove(this.primary_window_exists_storage_key)\n            }\n        })\n    }\n\n    /*\n     * This function returns the current sessionId and windowId. It should be used to\n     * access these values over directly calling `._sessionId` or `._windowId`. In addition\n     * to returning the sessionId and windowId, this function also manages cycling the\n     * sessionId and windowId when appropriate by doing the following:\n     *\n     * 1. If the sessionId or windowId is not set, it will generate a new one and store it.\n     * 2. If the readOnly param is set to false, it will:\n     *    a. Check if it has been > SESSION_CHANGE_THRESHOLD since the last call with this flag set.\n     *       If so, it will generate a new sessionId and store it.\n     *    b. Update the timestamp stored with the sessionId to ensure the current session is extended\n     *       for the appropriate amount of time.\n     *\n     * @param {boolean} readOnly (optional) Defaults to False. Should be set to True when the call to the function should not extend or cycle the session (e.g. being called for non-user generated events)\n     * @param {Number} timestamp (optional) Defaults to the current time. The timestamp to be stored with the sessionId (used when determining if a new sessionId should be generated)\n     */\n    checkAndGetSessionAndWindowId(readOnly = false, _timestamp: number | null = null) {\n        const timestamp = _timestamp || new Date().getTime()\n\n        // eslint-disable-next-line prefer-const\n        let [lastTimestamp, sessionId, startTimestamp] = this._getSessionId()\n        let windowId = this._getWindowId()\n\n        const sessionPastMaximumLength =\n            startTimestamp && startTimestamp > 0 && Math.abs(timestamp - startTimestamp) > SESSION_LENGTH_LIMIT\n\n        if (\n            !sessionId ||\n            (!readOnly && Math.abs(timestamp - lastTimestamp) > SESSION_CHANGE_THRESHOLD) ||\n            sessionPastMaximumLength\n        ) {\n            sessionId = _UUID()\n            windowId = _UUID()\n            startTimestamp = timestamp\n        } else if (!windowId) {\n            windowId = _UUID()\n        }\n\n        const newTimestamp = lastTimestamp === 0 || !readOnly || sessionPastMaximumLength ? timestamp : lastTimestamp\n        const sessionStartTimestamp = startTimestamp === 0 ? new Date().getTime() : startTimestamp\n\n        this._setWindowId(windowId)\n        this._setSessionId(sessionId, newTimestamp, sessionStartTimestamp)\n\n        return {\n            sessionId: sessionId,\n            windowId: windowId,\n        }\n    }\n}\n"]}